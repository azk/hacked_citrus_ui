# Autogenerated runCitrus.R File
# Compatible with Citrus version <%cat(templateData[["citrusVersion"]])%>

rm(list = ls())
library("citrus",lib.loc=NULL)

#**************************************************************************************
# IMPORTANT INFORMATION TO LIMIT # OF CORES Running. When this program is run on the cluster we MUST preserve control of the number of threads it uses or said 
# differently - so that it does not steal cores without the job scheduler knowing. There are 3 ways to do so:
# 1) In the call to function citrus.clusterAndMapFolds add the param mc.cores=16
# 2) Set the # of threads in the Rapp call like so: Rclusterpp.setThreads(X);options("mc.cores‚Äù=X);. Specifically, I think u should use 1 (ask David to be sure): 
# Rclusterpp.setThreads(1); options("mc.cores"=1);
# 3) Limit through the job scheduler using the P queue like so:
#qsub -q P -l nodes=tech-wn51.hep.technion.ac.il:ppn=4,nodes=tech-wn52.hep.technion.ac.il:ppn=4,nodes=tech-wn53.hep.technion.ac.il:ppn=4,nodes=tech-wn54.hep.technion.ac.il:ppn=4,nodes=tech-wn55.hep.technion.ac.il:ppn=4,nodes=tech-wn56.hep.technion.ac.il:ppn=4,nodes=tech-wn57.hep.technion.ac.il:ppn=4,nodes=tech-wn58.hep.technion.ac.il:ppn=4,nodes=tech-wn59.hep.technion.ac.il:ppn=4,nodes=tech-wn60.hep.technion.ac.il:ppn=4,nodes=tech-wn61.hep.technion.ac.il:ppn=4,nodes=tech-wn62.hep.technion.ac.il:ppn=4,nodes=tech-wn63.hep.technion.ac.il:ppn=4,nodes=tech-wn64.hep.technion.ac.il:ppn=4,nodes=tech-wn65.hep.technion.ac.il:ppn=4,nodes=tech-wn66.hep.technion.ac.il:ppn=4,nodes=tech-wn67.hep.technion.ac.il:ppn=4,nodes=tech-wn68.hep.technion.ac.il:ppn=4,nodes=tech-wn69.hep.technion.ac.il:ppn=4,nodes=tech-wn70.hep.technion.ac.il:ppn=4,nodes=tech-wn71.hep.technion.ac.il:ppn=4,nodes=tech-wn72.hep.technion.ac.il:ppn=4,nodes=tech-wn73.hep.technion.ac.il:ppn=4,nodes=tech-wn74.hep.technion.ac.il:ppn=4,nodes=tech-wn75.hep.technion.ac.il:ppn=4,nodes=tech-wn76.hep.technion.ac.il:ppn=4,nodes=tech-wn77.hep.technion.ac.il:ppn=4,nodes=tech-wn78.hep.technion.ac.il:ppn=4 -N VTA_SPBL  runCitrus2class.sh
#**********************************************************************************

# Use this line to limit the number of threads used by clustering
# 
<% for (param in c("DEFINE_PARAMETERS","GENERATE_CLUSTERS","COMPUTE_FEATURES_AND_DIFFERENCES", "PLOT_OUTPUT")) {
cat(param," = ")
if (param %in% templateData[["scriptFlags"]]) {
	cat("TRUE\n")
} else {
	cat("FALSE\n")
}}%>

if(DEFINE_PARAMETERS) {
  print('DEFINE_PARAMETERS')
	family = "classification"
	modelTypes = c(<% cat(paste(sapply(templateData[["classificationModels"]],stringQuote),collapse=",")) %>)
	nFolds = <%cat(templateData[["crossValidationFolds"]]) %>
	<%if (!templateData[["coreLimit"]]){cat("# ")}%>Rclusterpp.setThreads(<%cat(templateData[["analysisCores"]])%>);
	options("mc.cores"=1);	
  	featureTypes = c(<%cat(stringQuote(templateData[["featureType"]]))%>)
	citrusRes = list()
	citrusRes$General = list() #General is teh condition name
	cnd = 'General'

	# Change if you want to run from command line
	# dataDirectory = "../"

	citrusRes$comparison = 'ALL'
	dataDirectory = <%cat(stringQuote(templateData[["clusterInputDir"]]))%>
	#args <- commandArgs(trailingOnly = TRUE)
	citrusRes$minClustSzPrcnt = <%cat(templateData[["minimumClusterSizePercent"]])%>
	citrusRes$fileSampleSize = <% cat(templateData[["fileSampleSize"]]) %>                                            
	print(paste('fileSampleSize = ',citrusRes$fileSampleSize, 'min cluster size',citrusRes$minClustSzPrcnt))
	citrusRes$folderName = <%cat(stringQuote(templateData[["clusterOutputDir"]]))%>

  	fileList = data.frame(<%
                        if (templateData[["preload"]]){
                          labelAssignments=templateData[["keyFile"]]
                        } else {
                          selectedFiles = getSelectedFiles(input)
                          labelAssignments = convertToLabeledFileList(selectedFiles)
                        }
                        labelCol = which(colnames(labelAssignments)=="labels")
                        labels = labelAssignments[,labelCol]
                        labelAssignments = labelAssignments[,-labelCol,drop=F]
                        cat(paste(sapply(colnames(labelAssignments),convertColToDefinition,df=labelAssignments),collapse=",\n"))
                      %>)
  	citrusRes$sample.labels = as.factor(c(<%cat(paste(sapply(labels,stringQuote),collapse=","))%>))
  
  clusteringColumns = c(<%cat(paste(sapply(templateData[["clusterCols"]],stringQuote),collapse=","))%>)
<% if ("medianColumns" %in% names(templateData)) {
cat(paste("medianColumns=c(",paste(sapply(templateData[["medianColumns"]],stringQuote),collapse=","),")\n",sep=""))
}%>
  
  transformColumns = c(<%cat(ifelse(length(templateData[["transformCols"]])>0,paste(sapply(templateData[["transformCols"]],stringQuote),collapse=","),"NULL"))%>)
  transformCofactor = <%cat(ifelse(length(templateData[["transformCols"]])>0,templateData[["transformCofactor"]],"NULL"))%>
  
}
	
	
outputDir = paste(dataDirectory,'/',citrusRes$folderName,sep='')
if(!file.exists(outputDir)) {
  dir.create(outputDir,showWarnings = TRUE, recursive = TRUE)
}

if(GENERATE_CLUSTERS) {
#**************************************************************************************
# IMPORTANT - Use the commented out code below when run on cluster (see note on top)
#citrusRes$foldClustering = citrus.clusterAndMapFolds(citrusRes$combinedFCSSet,clusteringColumns,citrusRes$sample.labels,nFolds,mc.cores=16)
print('GENERATE_CLUSTERS\n')
# Read Data
	citrusRes$combinedFCSSet = citrus.readFCSSet(dataDirectory,fileList,citrusRes$fileSampleSize,transformColumns,transformCofactor)
	colnames(citrusRes$combinedFCSSet$fileId) = 'General'
	# Cluster all the data
	citrusRes$foldClustering = citrus.clusterAndMapFolds(citrusRes$combinedFCSSet,clusteringColumns,citrusRes$sample.labels,nFolds)
	print(paste('fileSampleSize = ',citrusRes$fileSampleSize, 'min cluster size',citrusRes$minClustSzPrcnt))
	save(file = paste(outputDir,'/citrusOutClustering.RData',sep=''),citrusRes,family,featureTypes,dataDirectory,outputDir,nFolds)  # save clustering
} else {
	load(file = paste(outputDir,'/citrusOutClustering.RData',sep=''))
}

if(COMPUTE_FEATURES_AND_DIFFERENCES) {
  print('COMPUTE_FEATURES_AND_DIFFERENCES\n')
  citrusRes$General = list() #General is teh condition name

	clusterIds = citrus.selectClusters.minimumClusterSize(citrusRes$foldClustering$allClustering,minimumClusterSizePercent = citrusRes$minClustSzPrcnt)
	#for(cnd in citrusRes$General) {
	  cnd = 'General'
    
		for(ft in featureTypes) {
		  if(ft == 'medians') {
				  citrusRes[[cnd]][[ft]]$foldFeatureSet = citrus.calculateFoldFeatureSet(citrusRes$foldClustering,citrusRes$combinedFCSSet,featureType=ft,minimumClusterSizePercent=citrusRes$minClustSzPrcnt,medianColumns=medianColumns)
			} else {
				citrusRes[[cnd]][[ft]]$foldFeatureSet = citrus.calculateFoldFeatureSet(citrusRes$foldClustering,citrusRes$combinedFCSSet,featureType=ft,minimumClusterSizePercent=citrusRes$minClustSzPrcnt) 
			}
			# Build regression models for each model type
				citrusRes[[cnd]][[ft]]$regressionResults = mclapply(modelTypes,citrus.endpointRegress,citrus.foldFeatureSet=citrusRes[[cnd]][[ft]]$foldFeatureSet,labels=citrusRes$sample.labels,family=family)
				# Plot Results for each model
		}
#	}  
  save(file = paste(outputDir,'/citrusOutFinal.RData',sep=''),citrusRes,family,featureTypes,dataDirectory,outputDir,nFolds)
} else {
	load(file = paste(outputDir,'/citrusOutFinal.RData',sep=''))
}
# 
if(PLOT_OUTPUT) {
  print('Plot output\n')
  for (conditionName in names(citrusRes$General)) {
    
    cat(paste0("\nPlotting Results for ", conditionName, "\n"))
    conditionOutputDir = paste(outputDir,'/',conditionName,sep='')
    dir.create(conditionOutputDir, showWarnings = F)
    lapply(citrusRes[[cnd]][[conditionName]]$regressionResults,plot,outputDirectory=conditionOutputDir,citrus.foldClustering=citrusRes$foldClustering,citrus.foldFeatureSet=citrusRes[[cnd]][[conditionName]]$foldFeatureSet,citrus.combinedFCSSet=citrusRes$combinedFCSSet)
  
#     mclapply(citrusRes$General[[conditionName]]$RegressionResults, 
#              plot, outputDirectory = conditionOutputDir, citrus.foldClustering = citrusRes$foldClustering, 
#              citrus.foldFeatureSet = citrusRes$General[[conditionName]]$foldFeatureSet, 
#              citrus.combinedFCSSet = citrusRes$combinedFCSSet, 
#              family = family, labels = citrusRes$sample.labels)
#     cat("\n")
  }  
}



